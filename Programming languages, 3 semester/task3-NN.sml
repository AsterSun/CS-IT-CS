(* N - целочисленный параметр *)
fun y (N : int) : real =
  let
    (* Так как в выражении присутствуют вещественнозначные операции 
     * (деление), параметры i и j будем рассматривать как вещественные 
     * числа и сравнивать с вещественным эквивалентом параметра N *)
    val rN = real N

    (* Внутренний цикл (произведение) - подсчет i-го слагаемого:     
     * произведение множителей, начиная с j-го (при j<=N) 
     * c аккумулятором slag (в котором уже предполагается наличие 
     * произведения с 1-го по j-1-й множитель).
     * В случае, если все нужные множители уже перемножены, 
     * выдается результат, а в противном случае вычисляется j-й множитель, 
     * перемножается на slag и вызывается подсчет произведения 
     * с остальными множителями. *)
    fun jIter (i : real, j : real, slag : real) : real =
      if j > rN 
      then slag
      else jIter (i, j + 1.0, slag * (i / j + i * i / 2.0))

    (* Внешний цикл (сумма): добавление слагаемых, начиная с i-го (при i<=N) 
     * к аккумулятору rez (в котором уже предполагается сумма 
     * с 1-го по i-1-е слагаемое).
     * В случае, если все слагаемые проссуммированы, выдается результат,
     * а в противном случае вычисляется i-е слагаемое, скаладывается с rez, 
     * и вызывается подсчет суммы с остальными слагаемыми. *)
    fun iIter (i : real, rez : real) : real =
      if i > rN 
      then rez
      else iIter (i + 1.0, rez + jIter (i, 1.0, 1.0))
  in
    (* Запускается цикл по i (сумма) от 1.0 *)
    iIter (1.0, 0.0)
  end

(* ТЕСТОВЫЕ ЗАПУСКИ *)
val test1 = y ~2
val test2 = y ~3
val test3 = y 2
val test4 = y 3
val test5 = y 4
val test6 = y 5
