;; —тратеги€ решени€ следующа€. Ѕудем просматривать элементы списка 
;; по уровн€м: сначала все эелементы первого уровн€, потом все элементы 
;; второго и т. д. Ёлементы следующего уровн€ можем получить 
;; объединив все элементы-списки текущего уровн€.
;; –ешение - функци€ от одного аргумента, но чтобы не определ€ть 
;; вспомогательной функции, определим дополнительные 
;; необ€зательные параметры
;; l - об€зательный параметр - заданный список
;; остальные параметры необ€зательные
;; new-l - список элементов следующего уровн€
;; cur-depth-num - номер текущего уровн€; первоначально равен 1
;; cnt - количество элементов текущего уровн€, €вл€ющихс€ списками
;; res - номер последнего уровн€, на котором обнаружено число
(defun number-depth (l &optional new-l (cur-depth-num 1) (cnt 0) (res 0))
  (if (null l)          ; если список l стал пустым 
      (if (= cnt 0) res ; и на текущем уровне не было подсписков, 
                        ; значит вернуть результат
          ; если же подсписки были, то есть еще один уровень, элементы которого
          ; составл€ют список new-l, от которого рекурсивно запускаем функцию
          (number-depth new-l () (+ cur-depth-num 1) 0 res))
      ; если список l пока не пустой, то в нем есть первый элемент, 
      ; обозначим его el
      (let ((el (car l)))
        (cond 
          ((numberp el) ; если el - число, то номер текущего уровн€ передаем 
                        ; в качестве параметра res при рекурсивном вызове
             (number-depth (cdr l) 
                           new-l 
                           cur-depth-num 
                           cnt 
                           cur-depth-num)) 
          ((listp el) ; если el - список, то его элементы добавл€ем  
                      ; к элементам следующего уровн€
             (number-depth (cdr l) 
                           (append el new-l) 
                           cur-depth-num 
                           (+ 1 cnt) 
                           res))
          ; в противном случае просто игнорируем элемент el
          (T (number-depth (cdr l) new-l cur-depth-num cnt res)))))) 

(print (number-depth '(5 (7 8 a) ((6 (b () 9) 7) s) b)))
(print (number-depth '(a b (c ((d e) f 5 (g) h) i (j (k () l))) 
                        (m (n ((o p (9))) q ((r) (s t))) (u ((v) w))) 
                        ((x) ()) ((((10 (() y))))))))
(print (number-depth '(() 6)))
(print (number-depth '()))


