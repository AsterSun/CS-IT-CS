fun delDupl x =
  let
    (* Вспомогательная функция определяется с помощью шаблонов.
     * Первый аргумент функции - обрабатываемый список, 
     * второй - формируемый в обратном порядке результат *)
      (* Если первый аргумент - пустой список, то результат 
       * сформирован, и остается его только перевернуть с 
       * помощью стандартной функции rev *)
    fun delDuplIter ([],  res) = rev res
      (* Если в обрабатываемом списке только один элемент,
       * то включаем его в результат и проводим рекурсивный
       * вызов *)
      | delDuplIter ([x], res) = delDuplIter ([], x :: res)
      (* В противном случае - в списке есть два первых элемента,
       * которые обозначаем через x1 и x2, при этом хвост списка
       * обозначаем через xs. Если x1 и x2 совпадают, 
       * x1 выбрасываем. В противном случае, 
       * x1 помещаем в результат *)
      | delDuplIter (x1 :: (xs as x2 :: _), res) =
          if x1 = x2 then delDuplIter (xs, res)
          else  delDuplIter (xs, x1 :: res)
  in
    delDuplIter (x, [])
  end

(* ТЕСТОВЫЕ ЗАПУСКИ *)
val test0 = delDupl []
val test1 = delDupl [12]
val test2 = delDupl [1, 2, 2, 2, 3, 3, 4, 5]
val test3 = delDupl [ 111, 111, 111, 2, 2, 2, 2, 3, 3, 3, 2, 2, 2, 1
                    , 1, 1, 2, 3, 3, 43, 4, 5, 6, 6, 4, 4, 4, 4 ]
val test4 = delDupl ["a", "b", "b", "b", "c", "c", "d", "e"]