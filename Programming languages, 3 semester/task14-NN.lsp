;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 1. блок дл€ реализации отложенных вычислений
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; макрос, создающий обещание (thunk из выражени€ expr)
(defmacro delay (expr)
  `(cons NIL (lambda () ,expr)))

;; функци€ вычислени€ обещани€  
(defun force (delay)
  (if (car delay) 
      (cdr delay)
      (progn (setf (car delay) T)
             (setf (cdr delay) (funcall (cdr delay))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 2. блок дл€ реализации потоков
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; макрос дл€ создани€ потока из головы a и хвоста str
;; результат вычислени€ str - поток
(defmacro cons-stream (a str)
  `(cons ,a (delay ,str)))      

;; функци€ извлечени€ головы потока (вместо car-stream)
(defun head (stream)
  (car stream))

;; функци€ извлечени€ хвоста потока (вместо cdr-stream)
(defun tail (stream)
  (force (cdr stream)))

;; функци€ проверки потока на пустоту
(defun empty-stream-p (stream)
  (null stream))  

;; определение глобальной переменной - пустой поток
(defvar *the-empty-stream* '())  

;; функци€ фильтрации потока stream с помощью предиката p
(defun filter-stream (p stream)
  (cond ((empty-stream-p stream) *the-empty-stream*)
        ((funcall p (head stream)) 
         (cons-stream (head stream) 
                      (filter-stream p (tail stream))))
        (T (filter-stream p (tail stream)))))

;; ниже должны быть определены вспомогательные функции 
;; дл€ работы с потоками дл€ индивидуального задани€
;; (defun drop (n stream))
;; (defun take (n stream))
;; возможны еще дополнительные функции в зависимости от задани€        
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 3. примеры потоков
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; глобальна€ переменна€, содержаща€ поток единиц
(defvar *ones*) ; объ€вление переменной
(setq *ones* (cons-stream 1 *ones*)) 

;; функци€, выдающа€ поток целых чисел, начинающийс€ с n
(defun integers-starting-from (n)
  (cons-stream n (integers-starting-from (+ n 1))))
  
;; вспомогательна€ функци€, провер€юща€ делитс€ ли x на y
(defun divisible-p (x y)
  (= (mod x y) 0))

;; функци€, получающа€ поток простых чисел из потока stream при условии,
;; что stream - возрастающа€ последовательность целых чисел в которой
;; головной элемент - простое число и в stream нет чисел, у которых
;; делител€ми €вл€ютс€ числа меньшие головного элемента (кроме единицы).
(defun sieve (stream)
  (cons-stream
    (head stream)
    (sieve 
      (filter-stream
        (lambda (x) (not (divisible-p x (head stream))))
        (tail stream)))))

;; глобальна€ переменна€, содержаща€ поток простых чисел
(defvar *primes* (sieve (integers-starting-from 2)))  

;; ниже должны быть определены вспомогательные функции/глобальные переменные 
;; дл€ индивидуального задани€

  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 4. тестовые примеры
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(print (head (tail (tail (tail (tail (tail *primes*))))))) ; 6-е простое число
(print 
  (head (tail (tail (tail (tail (tail (tail (tail *primes*))))))))) ; 8-е число

;; ниже должны быть определены примеры потока 
;; дл€ индивидуального задани€ с использованием функций drop и take
