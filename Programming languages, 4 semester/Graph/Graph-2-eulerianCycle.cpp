#include <iostream>
#include <vector>
#include <stack>

using namespace std;

// ВАЖНО! У данной задачи, в отличие от всех предыдущих, граф может
// являться мультиграфом и также возможно наличие петель. По этой причине
// реализация через map понесла бы серьёзное усложнение, поскольку
// пришлось бы хранить ещё и количество рёбер между двумя
// вершинами. Также данная задача рассматривается только для
// неориентированного невзвешенного графа, поэтому соответсвующие
// предикаты можно убрать. Список смежности будет представлен в виде
// вектора векторов, значением ячейки будет служить количество рёбер.
class Graph
{
public:
    int N;                   // Количество вершин
    int M;                   // Количество рёбер
    vector<vector<int>> Adj; // Список смежности

    Graph()
    { // Конструктор по умолчанию - 0 вершин, 0 рёбер, неориентированный, невзвешенный
        N = 0;
        M = 0;
    }

    Graph(int n, int m)
    { // Конструктор
        N = n;
        M = m;
    }

    // Функция создания списка смежности
    void createAdjList()
    {
        vector<vector<int>> Gr; // Инициализируем список смежности
        Gr.resize(N);           // Устанавливаем вектору векторов размер в количество вершин
        for (int i = 0; i < N; i++)
        {                               // Для каждой вершины
            Gr[i].resize(N);            // Устанавливаем вектору от i размер в количество вершин
            for (int j = 0; j < N; j++) // Для каждой вершины
                Gr[i][j] = 0;           // Обнуляем значение количества рёбер
        }
        for (int i = 0; i < M; i++)
        {                  // Для каждого ребра
            int x, y;      // Инициализируем x y
            cin >> x >> y; // Считываем x и y
            if ((x > N) || (y > N))
                ; // Если значения x и y не выходят за границы
            else
            {
                Gr[x][y]++; // Увеличиваем количество рёбер у x
                Gr[y][x]++; // Увеличиваем количество рёбер у у
            }
        }
        Adj = Gr; // Присваиваем списку смежности значения
    }

    // Функция вывода списка смежности
    void printAdj()
    {
        for (int i = 0; i < N; i++)
        {                                                  // Для каждой вершины
            cout << i << ": ";                             // Выводим номер вершины
            for (int j = 0; j < N; j++)                    // Для каждой вершины
                if (Adj[i][j] != 0)                        // Если есть рёбра i -> j
                    cout << j << "(" << Adj[i][j] << ") "; // Выводим их количество
            cout << endl;
        }
    }

    // Функция получения списка степеней вершин
    vector<int> getVertexesDegree()
    {
        vector<int> res; // Инициализируем вектор степеней
        res.resize(N);   // Задаём размер в количество вершин
        for (int i = 0; i < N; i++)
        {                               // Для каждой вершины
            res[i] = 0;                 // Обнуляем степень вершины
            for (int j = 0; j < N; j++) // Для каждой вершины
                res[i] += Adj[i][j];    // Увеличиваем количество рёбер
        }
        return res; // Возвращаем результат
    }

    /* 
	Функция, определяющая есть ли Эйлеров цикл
	Для реализации функции используется теорема Эйлера:
	
	Эйлеров цикл существует тогда и только тогда, когда граф связный 
	или будет являться связным, если удалить из него все изолированные вершины, 
	и в нём отсутствуют вершины нечётной степени.

    Эйлеров путь в графе существует тогда и только тогда, когда граф связный и 
	содержит не более двух вершин нечётной степени. Ввиду леммы о рукопожатиях, 
	число вершин с нечётной степенью должно быть четным. А значит эйлеров путь 
	существует только тогда, когда это число равно нулю или двум. Причём когда 
	оно равно нулю, эйлеров путь вырождается в эйлеров цикл.
	*/
    int isEulerCycle()
    {
        // Инициализируем и заполняем вектор степеней вершин
        vector<int> degrees = getVertexesDegree();
        int countOdd = 0;              // Инициализируем и обнуляем счётчик количества нечётных степеней
        for (int i = 0; i < N; i++)    // Для каждой вершины
            if ((degrees[i] % 2) == 1) // Если степень нечётная
                countOdd++;            // Увеличиваем счётчик нечётных степеней
        if (countOdd == 0)             // Если нечётных степеней нет
            return 1;                  // То есть Эйлеров цикл
        else if (countOdd == 2)        // Если нечётных степеней 2
            return 0;                  // То есть Эйлеров путь
        else
            return -1; // Иначе нет ни цикла, ни пути
    }

    // Функция получения эйлерова пути/цикла
    vector<int> getEulerCycle()
    {
        // Инициализируем и заполняем вектор степеней вершин
        vector<int> degrees = getVertexesDegree();
        // Создаём локальный список смежности,
        // чтобы не вносить изменения в глобальный
        vector<vector<int>> modAdj;
        // Проверяем, имеет ли граф эйлеров цикл/путь и запоминаем
        int status = isEulerCycle();
        int first = 0; // Объявляем точку начала
        // Если степень начальной точки равна нулю, идём к следующей
        while (!degrees[first])
            ++first;
        vector<int> res; // Инициализируем вектор результата
        if (status == -1)
        {               // Если граф не имеет Эйлерова пути/цикла
            res = {-1}; // Присваиваем результату -1
            return res; // И возвращаем результат
        }
        // Инициализируем переменные v1 и v2.
        // Они используются для создания мнимого ребра,
        // если Эйлерова цикла нет, а Эйлеров путь есть
        int v1 = -1, v2 = -1;
        if (status == 0)
        {                               // Если есть Эйлеров путь
            for (int i = 0; i < N; ++i) // Для каждой вершины
                if (degrees[i] & 1)     // Если степень нечётная (операция реализована через побитовое и)
                    if (v1 == -1)
                        v1 = i; // Если v1 ещё не использовался, присваиваем v1 номер нечётной степени
                    else if (v2 == -1)
                        v2 = i; // Иначе если v2 ещё не использовался, присваиваем v2 номер нечётной степени
                    else
                    { // Иначе возвращаем результат = -1
                        res = {-1};
                        return res;
                    }
            if (v1 != -1)                           // Если v1 был изменён в течение цикла, то
                ++modAdj[v1][v2], ++modAdj[v2][v1]; // Добавляем мнимое ребро v1 v2
        }
        stack<int> st;  // Инициализируем воспомогательный стек
        st.push(first); // Добавляем начальную вершину в стек
        while (!st.empty())
        {                           // Если стек не пустой
            int v = st.top();       // Присваиваем v голову стека
            int i;                  // Инициализируем i
            for (i = 0; i < N; ++i) // Для каждой вершины
                if (modAdj[v][i])   // Если существует ребро v i
                    break;          // Выходим из цикла
            if (i == N)             // Если на выходе из цикла i оказалась равной количеству вершин
            {
                res.push_back(v); // Записываем v в результат
                st.pop();         // Удаляем голову стека, то есть удаляем v из стека
            }
            else // Иначе
            {
                --modAdj[v][i]; // Убираем ребро v i
                --modAdj[i][v]; // Убираем ребро i V
                st.push(i);     // Добавляем i в верх стека
            }
        }
        if (v1 != -1) // Если v1 ранее был изменён
            // То на каждый элемент вектора результата, кроме последнего
            for (size_t i = 0; i + 1 < res.size(); ++i)
                // Если два соседних значения равны v1 и v2
                if (res[i] == v1 && res[i + 1] == v2 || res[i] == v2 && res[i + 1] == v1)
                {
                    vector<int> res2; // Инициализируем воспомогательный вектор результата
                    // Для каждого элемента вектора результата после i
                    for (size_t j = i + 1; j < res.size(); ++j)
                        res2.push_back(res[j]); // Вставляем в воспомогательный вектор значение
                    // Для каждого элемента вектора результата до i
                    for (size_t j = 1; j <= i; ++j)
                        res2.push_back(res[j]); // Вставляем в воспомогательный вектор значение
                    res = res2;                 // Присваиваем основному вектору значение воспомогательного
                    break;                      // Выходим из цикла
                }

        // Последний блок - весь воспомогательный список смежности
        // проверяется на пустоту. Если ещё остались неудалённые рёбра,
        // то это значит, что граф несвязный => он не может иметь ни
        // Эйлерова цикла, ни Эйлерова пути.
        for (int i = 0; i < N; ++i)
            for (int j = 0; j < N; ++j)
                if (modAdj[i][j])
                {
                    res = {-1};
                    return res;
                }
        return res; // Возвращаем результат
    }
};

int main()
{ // Ввод базовых параметров графа
    cout << "Enter number of vertexes and edges: " << endl;
    int nV, nE;
    cin >> nV >> nE;

    // Инициализация графа и ввод вершин
    // ВАЖНО: формат вноса ребёр - x y для ребра x <-> y
    Graph gr(nV, nE);
    cout << "Enter edges:" << endl;
    gr.createAdjList();

    // Вывод графа
    cout << endl;
    gr.printAdj();
    cout << endl;

    // Ищём и выводим Эйлеров путь или цикл,
    // предварительно проверив, могут ли они
    // существовать в данном графе.
    vector<int> res = gr.getEulerCycle();
    int status = gr.isEulerCycle();
    if (status == -1)
        cout << "Graph havent Eulerian cycle or path";
    else
    {
        cout << "Graph have Eulerian path" << endl;
        for (size_t i = 0; i < res.size(); ++i)
            cout << res[i] << " ";
    }
    return 0;
}