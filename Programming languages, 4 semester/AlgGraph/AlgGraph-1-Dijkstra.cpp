#include <iostream>
#include <vector>
#include <list>

using namespace std;

double INF = 10000.0; // Бесконечность
double EPS = 1.0;     // Погрешность при проверке на бесконечность

// Ориентированный взвешенный граф
class Graph
{
public:
    int N;                      // Количество вершин
    int M;                      // Количество рёбер
    vector<vector<double>> Adj; // Матрица смежности, где в ячейке Adj[x][y] хранится вес ребра x->y

    Graph(int n, int m)
    { // Конструктор
        N = n;
        M = m;
    }

    void createAdjList()
    {                  // Создание матрицы смежности
        int x, y;      // Инициализация вершин
        double w;      // Инициализация веса
        Adj.resize(N); // Устанавливаем размер внешнего вектора на количество вершин
        for (int i = 0; i < N; i++)
        {
            Adj[i].resize(N); // Устанавливаем размер внутреннего вектора на количество вершин
            for (int j = 0; j < N; j++)
                Adj[i][j] = INF; // Для каждой ячейки устанавливаем значение бесконечности, то есть отсутвие пути
        }
        cout << "Enter edges:" << endl;
        for (int i = 0; i < M; i++)
        {
            cin >> x >> y >> w; // Считываем каждое ребро
            Adj[x][y] = w;      // и устанавливаем значение ячейки, равное весу
        }
    }

    void printAdj()
    { // Вывод списка смежности
        for (int i = 0; i < N; i++)
        {
            cout << i << " : "; // Вершина, откуда выходит ребро
            for (int j = 0; j < N; j++)
            {                                                     // Перебираем список смежных вершин
                if (Adj[i][j] < INF - EPS)                        // Если значение не бесконечность
                    cout << " " << j << "(" << Adj[i][j] << ");"; // Выводим
            }
            cout << endl;
        }
    }

    // Алгоритм Дейкстры. Данная функция выводит длины кратчаших путей
    // из стартовой точки во все возможные, а сам кратчайший путь -
    // только для введённой пары вершин. Сделано это для того, чтобы
    // не перегружать вывод в консоли, так как количество путей между всеми
    // парами вершин при крупных графах довольно велико для удобного отображения.
    // Если бы потребовалось вывести длины путей для всех пар вершин, то
    // данную функцию нужно было бы применить для каждой стартовой вершины, то есть N раз.
    // Последнюю часть функции с выводом кратчашего пути также пришлось бы повторить N раз -
    // для каждой конечной вершины.
    void algorithmDijkstra(int x, int b)
    {                      // x - стартовая точка, b - конечная
        vector<int> fixed; // Вектор, определяющий является ли вершина фиксированной
        fixed.resize(N);   // Делаем размер вектора равным N
        vector<int> prev;  // Вектор предыдущих вершин
        prev.resize(N);    // Делаем размер вектора равным N
        for (int i = 0; i < N; i++)
        { // Обнуляем векторы
            fixed[i] = 0;
            prev[i] = 0;
        }
        fixed[x] = 1; // Фиксируем стартовую вершину
        // Инициализируем вектор кратчаших путей. Изначально он равен
        // длине прямых рёбер непосредственно из x в b
        vector<double> shortestWays = Adj[x];
        // Внешний общий цикл, который должен повториться N раз.
        // За один такой цикл происходит только одна фиксация
        // минимального значения и все связанные операции
        for (int p = 0; p < N; p++)
        {
            double MIN = INF; // Минимальное значение равно бесконечности
            // Инициализация w - минимальной вершины из еще не зафиксированных
            int w = -1;
            for (int i = 0; i < N; i++)
            {                  // Для каждой вершины
                if (!fixed[i]) // Если она не зафиксирована
                    if (shortestWays[i] < MIN)
                    {                          // И кратчаший путь из нее меньше минимального
                        MIN = shortestWays[i]; // Минимум равен значению вершины
                        w = i;                 // Саму вершину запоминаем
                    }
            }
            if (w == -1)                // Если минимальная вершина не найдена
                break;                  // Выходим из внешнего общего цикла
            fixed[w] = 1;               // Фиксируем минимальную вершину
            for (int j = 0; j < N; j++) // Для каждой вершины
                if (!fixed[j])          // Если она не зафиксирована
                    // И кратчаший путь в данную больше суммы кратчашего
                    // пути в минимальную вершину и ребра от минимальной
                    // вершины до данной
                    if (shortestWays[j] > shortestWays[w] + Adj[w][j])
                    {
                        // Кратчаший путь равен сумме кратчашего пути в минимальную
                        // вершину и ребра от минимальной вершины до данной
                        shortestWays[j] = shortestWays[w] + Adj[w][j];
                        prev[j] = w; // Предыдущая вершина равна минимальной вершине
                    }
        }

        list<int> out;   // Список на вывод
        int pointer = b; // Инициализация указателя
        while (pointer != x)
        {                            // Пока указатель не пришел в начальную точку
            pointer = prev[pointer]; // Указатель равен предыдущей вершине
            out.push_back(pointer);  // Добавляем новый указатель в вывод
        }
        out.reverse(); // Переворачиваем список
        // Выводим длину кратчайшего пути из x в b
        cout << "Length of way from a to b = " << shortestWays[b] << endl;
        // Выводим крачаший путь из x в b
        cout << "Shortest way from a to b:" << endl;
        for (auto iter = out.begin(); iter != out.end(); iter++)
        {
            cout << *iter << " -> ";
        }
        // Выводим саму b, так как указатель начинается с него
        // и данная вершина не попадает список вывода напрямую.
        // Можно было бы изменить программу так, что b учитывался
        // бы в цикле с указателем, но тогда было бы сложнее
        // организовать корректный вывод знаков ->, так как очевидно,
        // что у конечной вершины его быть не должно.
        cout << b;
    }
};

int main()
{
    // Чтение количества вершин и рёбер
    cout << "Enter number of vertexes and edges: " << endl;
    int nV, nE;
    cin >> nV >> nE;

    // Чтение рёбер графа и создание матрицы смежности
    Graph gr(nV, nE);
    gr.createAdjList();

    // Вывод матрицы смежности
    cout << endl;
    gr.printAdj();

    // Чтение начальной и конечной точки
    cout << "Enter start and end vertexes:" << endl;
    int a, b;
    cin >> a >> b;

    // Вывод кратчайшего пути и его длины
    gr.algorithmDijkstra(a, b);

    return 0;
}